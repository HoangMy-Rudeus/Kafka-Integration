# C2 - Component Architecture Description

**Last Updated**: September 16, 2025  
**Project Status**: Clean Architecture Implementation Complete  
**Architecture Pattern**: Domain-Driven Design with Clean Architecture  
**Current Phase**: Ready for Kafka Integration Enhancement

## Component-Level Architecture

### Clean Architecture Implementation Status

**âœ… Completed (September 2025)**:

- Domain Layer with entities, value objects, and domain events
- Application Layer with repository interfaces and command objects  
- Infrastructure Layer with repository implementations and type mapping
- Proper separation of concerns following DDD principles
- Type-safe value objects and strongly-typed domain entities
- Successful build validation with all errors resolved

### Service Component Breakdown

#### Order Service Component

```mermaid
graph TB
    subgraph "Order Service - Clean Architecture"
        subgraph "Presentation Layer"
            OC[OrdersController]
            API[REST API Endpoints]
        end
        
        subgraph "Application Layer"
            OAS[IOrderApplicationService]
            CMD[Command Objects]
            REPO_INT[IOrderRepository]
            UOW[IUnitOfWork]
        end
        
        subgraph "Domain Layer"
            ORDER_ENT[Order Entity]
            ORDER_ITEM_ENT[OrderItem Entity]
            MONEY[Money ValueObject]
            CUSTOMER_ID[CustomerId ValueObject]
            PRODUCT_ID[ProductId ValueObject]
            DOM_EVENTS[Domain Events]
        end
        
        subgraph "Infrastructure Layer"
            ORDER_REPO[OrderRepository]
            ORDER_MAPPER[OrderMapper]
            UOW_IMPL[UnitOfWork]
            ODC[OrderDbContext]
            KP[KafkaProducerService]
        end
        
        subgraph "Database Models"
            ORDER_MODEL[Order Model]
            ORDER_ITEM_MODEL[OrderItem Model]
        end
    end
    
    OC --> OAS
    OAS --> REPO_INT
    OAS --> UOW
    OC --> API
    
    ORDER_ENT --> ORDER_ITEM_ENT
    ORDER_ENT --> MONEY
    ORDER_ENT --> CUSTOMER_ID
    ORDER_ENT --> PRODUCT_ID
    ORDER_ENT --> DOM_EVENTS
    
    REPO_INT -.-> ORDER_REPO
    UOW -.-> UOW_IMPL
    ORDER_REPO --> ORDER_MAPPER
    ORDER_MAPPER --> ORDER_MODEL
    ORDER_MAPPER --> ORDER_ITEM_MODEL
    ORDER_REPO --> ODC
    UOW_IMPL --> ODC
    
    OAS --> KP
    
    style OC fill:#e1f5fe
    style OAS fill:#fff3e0
    style ORDER_ENT fill:#e8f5e8
    style ORDER_REPO fill:#f3e5f5
    style ODC fill:#e0f2f1
```

**Responsibilities:**

- **Presentation Layer**: REST API endpoint management and HTTP request/response handling
- **Application Layer**: Order business logic orchestration and external service coordination
- **Domain Layer**: Core business rules, entities, value objects, and domain events
- **Infrastructure Layer**: Data persistence, external service integration, and technical concerns

**Clean Architecture Benefits Achieved:**

- **Dependency Inversion**: Domain layer independent of infrastructure concerns
- **Type Safety**: Value objects prevent primitive obsession and type confusion
- **Testability**: Each layer can be tested independently with proper abstractions
- **Maintainability**: Clear separation of concerns and single responsibility principle

**Key Interfaces:**

- `IOrderApplicationService` - Application service contract for order operations
- `IOrderRepository` - Domain repository abstraction for order persistence
- `IUnitOfWork` - Transaction management abstraction
- `IKafkaProducer<BaseEvent>` - Event publishing interface
- REST endpoints for order operations (`/api/orders`)

**Domain Model:**

- `Order` entity with business logic encapsulation
- `OrderItem` entity for order line items
- `Money` value object for monetary amounts with currency support
- `CustomerId` and `ProductId` value objects for type safety
- Domain events for order lifecycle (`OrderCreated`, `OrderConfirmed`, etc.)

#### Inventory Service Component

```mermaid
graph TB
    subgraph "Inventory Service - Clean Architecture Ready"
        subgraph "Presentation Layer"
            IC[InventoryController]
            API_INV[REST API Endpoints]
        end
        
        subgraph "Application Layer"
            IS[InventoryService]
            KC[KafkaConsumerService]
            OEH[OrderEventHandler]
        end
        
        subgraph "Data Layer"
            IDC[InventoryDbContext]
            INVENTORY[Inventory Model]
        end
        
        subgraph "Events"
            INVENTORY_RESERVED[InventoryReservedEvent]
            ORDER_CREATED_HANDLER[OrderCreated Handler]
        end
    end
    
    IC --> IS
    IC --> API_INV
    IS --> IDC
    KC --> OEH
    OEH --> IS
    IS --> INVENTORY_RESERVED
    IS --> INVENTORY
    KC --> ORDER_CREATED_HANDLER
    ORDER_CREATED_HANDLER --> IS
    
    style IC fill:#e8f5e8
    style IS fill:#e8f5e8
    style KC fill:#f3e5f5
    style OEH fill:#f3e5f5
    style IDC fill:#e0f2f1
```

**Responsibilities:**

- **Inventory Management**: Track and manage product inventory levels
- **Event Processing**: Consume and handle order-related events from Kafka
- **Reservation Logic**: Reserve inventory for confirmed orders
- **Status Reporting**: Provide inventory status via REST API
- **Data Persistence**: Maintain inventory state in database

**Ready for Clean Architecture**: The Inventory Service is prepared for clean architecture refactoring following the Order Service pattern.

**Key Interfaces:**

- `IInventoryService` - Inventory operations and business logic
- `IKafkaConsumer<BaseEvent>` - Event consumption interface  
- Background service for continuous event processing
- REST endpoints for inventory operations (`/api/inventory`)

**Current Implementation Status:**

- âœ… Basic service structure with event handling
- ðŸ”„ Ready for clean architecture implementation
- ðŸ“‹ Planned: Domain model extraction and repository pattern

#### Notification Service Component

```mermaid
graph TB
    subgraph "Notification Service - Clean Architecture Ready"
        subgraph "Presentation Layer"
            NC[NotificationsController]
            API_NOT[REST API Endpoints]
        end
        
        subgraph "Application Layer"
            NS[NotificationService]
            KC[KafkaConsumerService]
            EH[EventHandler]
        end
        
        subgraph "Data Layer"
            NDC[NotificationDbContext]
            NOTIFICATION[Notification Model]
        end
        
        subgraph "Event Handlers"
            ORDER_HANDLER[OrderCreatedHandler]
            INVENTORY_HANDLER[InventoryReservedHandler]
        end
    end
    
    NC --> NS
    NC --> API_NOT
    NS --> NDC
    KC --> EH
    EH --> ORDER_HANDLER
    EH --> INVENTORY_HANDLER
    ORDER_HANDLER --> NS
    INVENTORY_HANDLER --> NS
    NS --> NOTIFICATION
    
    style NC fill:#fff3e0
    style NS fill:#fff3e0
    style KC fill:#f3e5f5
    style EH fill:#f3e5f5
    style NDC fill:#e0f2f1
```

**Responsibilities:**

- **Multi-Event Processing**: Handle multiple event types (order, inventory) from Kafka
- **Notification Generation**: Create customer notifications based on business events
- **Message Composition**: Format and structure notification messages
- **History Management**: Persist notification history for audit and retry
- **Test Endpoints**: Provide REST API for notification testing and management

**Ready for Clean Architecture**: The Notification Service is prepared for clean architecture refactoring.

**Key Interfaces:**

- `INotificationService` - Notification business logic and operations
- `IKafkaConsumer<BaseEvent>` - Multi-event consumption interface
- Background service for continuous event processing
- REST endpoints for notification operations (`/api/notifications`)

**Current Implementation Status:**

- âœ… Multi-event handler implementation
- âœ… Background service for event processing
- ðŸ”„ Ready for clean architecture implementation
- ðŸ“‹ Planned: Domain model for notification rules and templates

### Shared Components

#### Shared Library Component - Clean Architecture Foundation

```mermaid
graph TB
    subgraph "KafkaMicroservices.Shared - Clean Architecture"
        subgraph "Domain Layer"
            subgraph "Entities"
                ORDER_ENT[Order Entity]
                ORDER_ITEM_ENT[OrderItem Entity]
                BASE_ENTITY[BaseEntity]
            end
            
            subgraph "Value Objects"
                MONEY[Money]
                CUSTOMER_ID[CustomerId]
                PRODUCT_ID[ProductId]
            end
            
            subgraph "Domain Events"
                BASE_DOMAIN_EVENT[BaseDomainEvent]
                ORDER_CREATED_DOM[OrderCreated]
                ORDER_CONFIRMED_DOM[OrderConfirmed]
                ORDER_COMPLETED_DOM[OrderCompleted]
                ORDER_CANCELLED_DOM[OrderCancelled]
            end
        end
        
        subgraph "Application Layer"
            subgraph "Repositories"
                ORDER_REPO_INT[IOrderRepository]
                UOW_INT[IUnitOfWork]
            end
            
            subgraph "Services"
                ORDER_APP_SERVICE[IOrderApplicationService]
            end
        end
        
        subgraph "Infrastructure Layer"
            subgraph "Kafka Services"
                KAFKA_PRODUCER[IKafkaProducer]
                KAFKA_CONSUMER[IKafkaConsumer]
                MESSAGE_SERIALIZER[MessageSerializer]
            end
            
            subgraph "Repositories"
                ORDER_REPO_IMPL[OrderRepository]
                UOW_IMPL[UnitOfWork]
                ORDER_MAPPER[OrderMapper]
            end
        end
        
        subgraph "Events (Legacy)"
            BASE_EVENT[BaseEvent]
            ORDER_CREATED[OrderCreatedEvent]
            INVENTORY_RESERVED[InventoryReservedEvent]
        end
        
        subgraph "Models (Database)"
            ORDER_MODEL[Order Model]
            ORDER_ITEM_MODEL[OrderItem Model] 
            INVENTORY_MODEL[Inventory Model]
            NOTIFICATION_MODEL[Notification Model]
        end
        
        subgraph "Configuration"
            KAFKA_SETTINGS[KafkaSettings]
            TOPICS[Topics]
        end
    end
    
    ORDER_ENT --> ORDER_ITEM_ENT
    ORDER_ENT --> MONEY
    ORDER_ENT --> CUSTOMER_ID
    ORDER_ENT --> PRODUCT_ID
    ORDER_ENT --> BASE_ENTITY
    
    ORDER_CREATED_DOM --> BASE_DOMAIN_EVENT
    ORDER_CONFIRMED_DOM --> BASE_DOMAIN_EVENT
    ORDER_COMPLETED_DOM --> BASE_DOMAIN_EVENT
    ORDER_CANCELLED_DOM --> BASE_DOMAIN_EVENT
    
    ORDER_REPO_INT -.-> ORDER_REPO_IMPL
    UOW_INT -.-> UOW_IMPL
    ORDER_REPO_IMPL --> ORDER_MAPPER
    ORDER_MAPPER --> ORDER_MODEL
    ORDER_MAPPER --> ORDER_ITEM_MODEL
    
    ORDER_CREATED --> BASE_EVENT
    INVENTORY_RESERVED --> BASE_EVENT
    ORDER_MODEL --> ORDER_ITEM_MODEL
    
    style ORDER_ENT fill:#e8f5e8
    style MONEY fill:#e8f5e8
    style ORDER_REPO_INT fill:#fff3e0
    style ORDER_REPO_IMPL fill:#f3e5f5
    style BASE_EVENT fill:#fce4ec
```

**Responsibilities:**

- **Domain Foundation**: Core business entities, value objects, and domain events shared across services
- **Application Contracts**: Repository and service interfaces for dependency inversion
- **Infrastructure Abstractions**: Kafka integration interfaces and messaging contracts
- **Type Safety**: Value objects and strongly-typed identifiers to prevent errors
- **Clean Architecture Support**: Proper layer separation and dependency management
- **Legacy Event Support**: Maintains backward compatibility with existing event system
- **Data Mapping**: Conversion between domain entities and database models
- **Configuration Management**: Centralized Kafka and application settings

**Clean Architecture Achievements:**

- âœ… **Domain Layer**: Complete with entities, value objects, and domain events
- âœ… **Application Layer**: Repository interfaces and application service contracts
- âœ… **Infrastructure Layer**: Repository implementations with proper mapping
- âœ… **Type Safety**: Money, CustomerId, ProductId value objects implemented
- âœ… **Build Validation**: All compilation errors resolved and build successful

**Migration Strategy:**

- **Phase 1**: âœ… Domain layer foundation (completed)
- **Phase 2**: ðŸ”„ Service-by-service clean architecture adoption
- **Phase 3**: ðŸ“‹ Legacy event system replacement with domain events
- **Phase 4**: ðŸ“‹ Full integration testing and validation

### Component Interaction Patterns

#### Event Publishing Pattern

```mermaid
sequenceDiagram
    participant Controller
    participant Service
    participant KafkaProducer
    participant Kafka
    
    Controller->>Service: Business Operation
    Service->>Service: Process Business Logic
    Service->>KafkaProducer: ProduceAsync(event)
    KafkaProducer->>KafkaProducer: Serialize Event
    KafkaProducer->>Kafka: Publish to Topic
    Kafka-->>KafkaProducer: Acknowledgment
    KafkaProducer-->>Service: Completion
    Service-->>Controller: Result
```

#### Event Consumption Pattern

```mermaid
sequenceDiagram
    participant Kafka
    participant KafkaConsumer
    participant EventHandler
    participant Service
    participant Database
    
    Kafka->>KafkaConsumer: Event Message
    KafkaConsumer->>KafkaConsumer: Deserialize Event
    KafkaConsumer->>EventHandler: HandleEvent(event)
    EventHandler->>Service: ProcessEvent(event)
    Service->>Database: Persist Changes
    Database-->>Service: Confirmation
    Service-->>EventHandler: Completion
    EventHandler-->>KafkaConsumer: Success
```

### Data Flow Architecture

#### Service-Specific Data Stores

- **Order Service Database**: Orders, OrderItems tables
- **Inventory Service Database**: Inventory table with stock levels
- **Notification Service Database**: Notifications table with customer messages

#### Cross-Service Data Consistency

- **Event-Driven Consistency**: Changes propagated via Kafka events
- **No Direct Database Access**: Services only access their own data stores
- **Eventual Consistency**: Data synchronization through event processing

### Component Configuration

#### Environment Configuration

- **Service-Specific**: Each service has its own appsettings.json
- **Kafka Configuration**: Consistent broker settings across services
- **Database Connections**: Service-specific PostgreSQL connections
- **Docker Environment**: Container-specific environment variables

#### Dependency Injection Structure

- **Scoped Services**: Entity Framework DbContext and business services
- **Singleton Services**: Kafka producers/consumers and settings
- **Hosted Services**: Background event processors

### Monitoring and Health Components

#### Health Check Pattern

- **Service Health**: Individual service status endpoints
- **Dependency Health**: Database and Kafka connectivity checks
- **Aggregate Health**: Overall system health reporting

#### Logging Strategy

- **Structured Logging**: JSON format with correlation IDs
- **Service Identification**: Clear service boundaries in logs
- **Event Tracking**: Complete event flow visibility

## Current Implementation Status and Next Steps

### âœ… Completed (September 2025)

**Clean Architecture Foundation:**

- Complete domain layer implementation in Shared library
- Order Service fully migrated to clean architecture
- Repository pattern with proper abstractions
- Value objects for type safety and domain modeling
- Domain events infrastructure ready for integration

**Technical Achievements:**

- All compilation errors resolved
- Type mapping between database and domain models
- Proper dependency inversion with interfaces
- Successful build validation across all services

### ðŸ”„ Current Priority: Kafka Integration Enhancement

**Next Phase Goals:**

- Replace simulation mode with real Kafka consumers
- Implement proper Confluent.Kafka integration
- Add error handling and retry mechanisms for event processing
- Validate end-to-end event processing with clean architecture

### ðŸ“‹ Planned Enhancements

**Clean Architecture Expansion:**

- Migrate Inventory Service to clean architecture pattern
- Migrate Notification Service to clean architecture pattern
- Implement domain events to replace legacy event system
- Add comprehensive integration testing

**System Improvements:**

- Enhanced monitoring and observability
- Performance optimization and load testing
- Advanced error handling and circuit breaker patterns
- Event sourcing capabilities for audit trails

## Architecture Decision Impact

The clean architecture implementation provides a solid foundation for the upcoming Kafka integration enhancement. The separation of concerns and dependency inversion principles will make the Kafka consumer implementation more testable, maintainable, and resilient.

---
Generated by Copilot
